id	category	input_pattern	expected_output	output_type	status	notes
JSX-001	Basic JSX	<div>Hello</div>	<div>Hello</div>	preserve	✅ Implemented	Text content preserved
JSX-002	Basic JSX	<div>\n  Hello\n</div>	<div>Hello</div>	markedJsx	✅ Implemented	Indentation whitespace removed
JSX-003	Basic JSX	<div>{' '}</div>	<div> </div>	markedJsx	✅ Implemented	Explicit space preserved
JSX-004	Basic JSX	<div><p>A</p><span>B</span></div>	<div><p>A</p><span>B</span></div>	preserve	✅ Implemented	Nested elements preserved
JSX-005	Basic JSX	<input type='text' />	<input type='text' />	preserve	✅ Implemented	Self-closing preserved
JSX-006	Basic JSX	<br />	<br />	preserve	✅ Implemented	Void element supported
JSX-007	Basic JSX	<img src='x.png' alt='X' />	<img src='x.png' alt='X' />	preserve	✅ Implemented	Attrs on void element
JSX-008	Basic JSX	<></>	<></>	preserve	✅ Implemented	Empty fragment
JSX-009	Basic JSX	<><p>A</p><p>B</p></>	<><p>A</p><p>B</p></>	preserve	✅ Implemented	Fragment with children
JSX-010	Basic JSX	<><p>{count()}</p></>	<><p data-bf-scope='C' data-bf='0'>{count()}</p></>	both	✅ Implemented	First element gets scope marker
JSX-011	Basic JSX	<><><span>A</span></><div>B</div></>	<><span>A</span><div>B</div></>	markedJsx	✅ Implemented	Nested fragments flattened
JSX-012	Basic JSX	<>Hello<span>World</span>!</>	<>Hello<span>World</span>!</>	preserve	✅ Implemented	Mixed text and elements
JSX-013	Basic JSX	<><div>Only</div></>	<><div data-bf-scope='C'>Only</div></>	markedJsx	✅ Implemented	Single child gets scope
ATTR-001	Attributes	<div id='main'>X</div>	<div id='main'>X</div>	preserve	✅ Implemented	Static string attr preserved
ATTR-002	Attributes	<input disabled />	<input disabled />	preserve	✅ Implemented	Boolean shorthand
ATTR-003	Attributes	<div class='foo'>X</div>	<div className='foo'>X</div>	markedJsx	✅ Implemented	class -> className
ATTR-004	Attributes	<svg>...</svg>	<svg xmlns='http://www.w3.org/2000/svg'>...</svg>	markedJsx	✅ Implemented	SVG gets xmlns
ATTR-005	Attributes	<svg viewBox='0 0 24 24'>	<svg viewBox='0 0 24 24'>	preserve	✅ Implemented	camelCase preserved
ATTR-010	Attributes	<p class={active ? 'on' : 'off'}>X</p>	clientJs: _0.setAttribute('class', active ? 'on' : 'off')	clientJs	✅ Implemented	Dynamic class in effect
ATTR-011	Attributes	<p style={{ color: isRed() ? 'red' : 'blue' }}>X</p>	clientJs: Object.assign(_0.style, {...})	clientJs	✅ Implemented	Style object assignment
ATTR-012	Attributes	<p style={styleStr}>X</p>	clientJs: _0.style.cssText = styleStr	clientJs	✅ Implemented	Style string attribute with E2E test
ATTR-013	Attributes	<button disabled={loading()}>Go</button>	clientJs: _0.disabled = loading()	clientJs	✅ Implemented	Boolean property
ATTR-014	Attributes	<input value={text()} />	clientJs: if (__val !== undefined) _0.value = __val	clientJs	✅ Implemented	Value with undefined check
ATTR-015	Attributes	<div hidden={isHidden()}>X</div>	clientJs: _0.hidden = isHidden()	clientJs	✅ Implemented	Hidden property
ATTR-016	Attributes	<input checked={isOn()} />	clientJs: _0.checked = isOn()	clientJs	✅ Implemented	Checked property
ATTR-017	Attributes	<div data-id={id()}>X</div>	clientJs: _0.setAttribute('data-id', id())	clientJs	✅ Implemented	Data attribute with E2E test
ATTR-018	Attributes	<p class={a() ? b() : c()}>X</p>	clientJs: createEffect(() => _0.setAttribute('class', ...))	clientJs	✅ Implemented	Complex ternary in effect
ATTR-020	Attributes	<div {...props}>X</div>	<div {...props}>X</div>	preserve	✅ Implemented	Spread preserved
ATTR-021	Attributes	<div {...a} {...b}>X</div>	<div {...a} {...b}>X</div>	preserve	✅ Implemented	Multiple spreads
ATTR-022	Attributes	<div id='x' {...props}>X</div>	<div id='x' {...props}>X</div>	preserve	✅ Implemented	Static + spread
ATTR-023	Attributes	<input {...props} />	<input {...props} />	preserve	✅ Implemented	Spread on self-closing
EXPR-001	Expressions	const [count, setCount] = createSignal(0)	clientJs: const [count, setCount] = createSignal(0)	clientJs	✅ Implemented	Number signal extracted
EXPR-002	Expressions	const [on, setOn] = createSignal(false)	clientJs: const [on, setOn] = createSignal(false)	clientJs	✅ Implemented	Boolean signal
EXPR-003	Expressions	const [text, setText] = createSignal('hi')	clientJs: const [text, setText] = createSignal('hi')	clientJs	✅ Implemented	String signal
EXPR-004	Expressions	const [a] = createSignal(0); const [b] = createSignal(1)	clientJs: both signals extracted	clientJs	✅ Implemented	Multiple signals
EXPR-005	Expressions	const [user, setUser] = createSignal({name: 'A'})	clientJs: const [user, setUser] = createSignal({name: 'A'})	clientJs	✅ Implemented	Object signal
EXPR-006	Expressions	const [items, setItems] = createSignal([])	clientJs: const [items, setItems] = createSignal([])	clientJs	✅ Implemented	Array signal
EXPR-010	Expressions	const doubled = createMemo(() => count() * 2)	clientJs: const doubled = createMemo(() => count() * 2)	clientJs	✅ Implemented	Memo extracted
EXPR-011	Expressions	const memo = createMemo(() => { return x })	clientJs: (() => { return x })()	clientJs	✅ Implemented	createMemo with block body E2E test
EXPR-012	Expressions	const a = createMemo(...); const b = createMemo(() => a())	clientJs: both memos with deps	clientJs	✅ Implemented	Chained memos E2E test
EXPR-020	Expressions	<p>{count()}</p>	clientJs: createEffect(() => { _0.textContent = count() })	both	✅ Implemented	Signal in text
EXPR-021	Expressions	<p>{a() + b()}</p>	clientJs: createEffect(() => { _0.textContent = a() + b() })	both	✅ Implemented	Multiple deps
EXPR-022	Expressions	<p>{show() ? 'A' : 'B'}</p>	clientJs: createEffect(() => { _0.textContent = show() ? 'A' : 'B' })	both	✅ Implemented	Ternary in text
EXPR-023	Expressions	<p>Count: {count()}</p>	clientJs: _0.textContent = 'Count: ' + count()	both	✅ Implemented	Text + dynamic
EXPR-024	Expressions	<p>{doubled()}</p>	clientJs: createEffect(() => { _0.textContent = doubled() })	both	✅ Implemented	Memo call
EXPR-025	Expressions	<p>{value}</p> (value is prop)	clientJs: createEffect(() => { _0.textContent = value() })	both	✅ Implemented	Prop becomes getter
EXPR-026	Expressions	<div>{children}</div>	clientJs: always dynamic (lazy children)	both	✅ Implemented	Children always dynamic
EXPR-030	Expressions	const X = 5; <p>{X}</p>	clientJs: const X = 5	clientJs	✅ Implemented	Module const extracted
EXPR-031	Expressions	function fmt(x) {...}; <p>{fmt(v)}</p>	clientJs: function fmt(x) {...}	clientJs	✅ Implemented	Module fn extracted
EXPR-032	Expressions	function C() { const x = 1; return <p>{x}</p> }	clientJs: const x = 1	clientJs	✅ Implemented	Local var included
EXPR-033	Expressions	function C() { const fn = () => {}; ... }	clientJs: const fn = () => {}	clientJs	✅ Implemented	Local fn included
EXPR-034	Expressions	const X = 5; <Child value={X} />	clientJs: const X = 5	clientJs	✅ Implemented	Const in child props
EXPR-040	Expressions	const [x] = createSignal(propWithDefault)	markedJsx: (propWithDefault ?? 'default')	markedJsx	✅ Implemented	Prop default fallback for SSR
EXPR-050	Expressions	createEffect(() => { localStorage.setItem(...) })	clientJs: createEffect(() => { localStorage.setItem(...) })	clientJs	✅ Implemented	User-written effect preserved
EXPR-051	Expressions	createEffect(() => { const v = localStorage.getItem(...); setX(v) })	clientJs: effect preserved	clientJs	✅ Implemented	Effect reads localStorage
EXPR-052	Expressions	createEffect(() => { document.body.setAttribute(...) })	clientJs: effect preserved	clientJs	✅ Implemented	Effect updates external DOM
EXPR-053	Expressions	createEffect(...); createEffect(...)	clientJs: both effects preserved	clientJs	✅ Implemented	Multiple effects
EXPR-054	Expressions	Only createEffect + static JSX	clientJs: effect in output	clientJs	✅ Implemented	Effect-only component
CTRL-001	Control Flow	{true ? 'A' : 'B'}	'A' (evaluated at compile time)	markedJsx	✅ Implemented	Static ternary
CTRL-002	Control Flow	<p>{show() ? 'Yes' : 'No'}</p>	clientJs: _0.textContent = show() ? 'Yes' : 'No'	both	✅ Implemented	Dynamic text ternary
CTRL-003	Control Flow	{show() ? <A/> : <B/>}	markedJsx: <A data-bf-cond='0'/> + <B data-bf-cond='0'/>	both	✅ Implemented	Element ternary
CTRL-004	Control Flow	{show() && <A/>}	Same as {show() ? <A/> : null}	both	✅ Implemented	Logical AND
CTRL-005	Control Flow	{loading || <A/>}	Inverted: {!loading ? <A/> : null}	both	✅ Implemented	Logical OR
CTRL-006	Control Flow	{show() ? <A/> : null}	markedJsx: <A data-bf-cond='0'/> + DOM remove/insert	both	✅ Implemented	Null branch
CTRL-007	Control Flow	{show() ? <><A/><B/></> : <C/>}	markedJsx: <!--bf-cond-start:0--><A/><B/><!--bf-cond-end:0-->	both	✅ Implemented	Fragment uses comments
CTRL-008	Control Flow	{a() ? <A/> : b() ? <B/> : <C/>}	Nested data-bf-cond markers	both	✅ Implemented	Nested ternary
CTRL-009	Control Flow	{true ? <A/> : <B/>}	No data-bf-cond (static)	markedJsx	✅ Implemented	Static conditional
CTRL-010	Control Flow	<ul>{items().map(i => <li>{i}</li>)}</ul>	clientJs: _0.innerHTML = items().map(...).join('')	both	✅ Implemented	Array map
CTRL-011	Control Flow	items().filter(...).map(...)	Chain preserved in clientJs	clientJs	✅ Implemented	Filter + map
CTRL-012	Control Flow	<li key={item.id}>...</li>	<li data-key={item.id}>...</li>	markedJsx	✅ Implemented	key -> data-key
CTRL-013	Control Flow	items().map((item, i) => <li key={i}>)	key uses __index	markedJsx	✅ Implemented	Index key
CTRL-014	Control Flow	<li key={item.a + item.b}>	Complex key expression preserved	markedJsx	✅ Implemented	Computed key
CTRL-015	Control Flow	items().map(i => i.subs.map(s => <X/>))	Nested innerHTML	clientJs	✅ Implemented	Nested map
CTRL-016	Control Flow	items().map(i => i.done ? <A/> : <B/>)	Ternary in template string	clientJs	✅ Implemented	Conditional in map
CTRL-020	Control Flow	{a ? (b ? <X/> : <Y/>) : <Z/>}	Properly escaped template literal	clientJs	✅ Implemented	Nested ternary JSX escaping
COMP-001	Components	<Child />	<Child /> (direct render)	preserve	✅ Implemented	Static component
COMP-002	Components	<Child name='A' />	Props passed to Child	preserve	✅ Implemented	Static props
COMP-003	Components	<Child value={count()} />	Props wrapped: { value: () => count() }	clientJs	✅ Implemented	Dynamic props wrapped
COMP-004	Components	<Child {...props} />	Spread preserved	preserve	✅ Implemented	Spread props
COMP-005	Components	<Card><p>X</p></Card>	Children passed to Card	preserve	✅ Implemented	Children
COMP-006	Components	<Toggle active />	active={true}	markedJsx	✅ Implemented	Boolean shorthand
COMP-010	Components	function C({ name }: { name: string })	Type info extracted	clientJs	✅ Implemented	Typed props
COMP-011	Components	function C({ x = 5 }: Props)	x marked optional	clientJs	✅ Implemented	Default value
COMP-012	Components	<Child value={sig()} />	value: () => sig()	clientJs	✅ Implemented	Dynamic wrapped
COMP-013	Components	<Child onClick={fn} />	onClick: fn (not wrapped)	clientJs	✅ Implemented	Callback not wrapped
COMP-014	Components	function Child({ value }) { return <p>{value()}</p> }	Prop accessed as getter	clientJs	✅ Implemented	Prop usage
COMP-015	Components	<Child name='A' />	name: 'A' (not wrapped)	preserve	✅ Implemented	Static not wrapped
COMP-020	Components	<Card>{count()}</Card>	children: () => count()	clientJs	✅ Implemented	Reactive children
COMP-021	Components	<Card><p>Static</p></Card>	children: <p>Static</p>	preserve	✅ Implemented	Static children
COMP-022	Components	{children} in component	typeof children === 'function' ? children() : children	clientJs	✅ Implemented	Lazy children
COMP-023	Components	<Card>{show() ? <A/> : <B/>}</Card>	No children prop (SSR DOM preserved)	preserve	✅ Implemented	Complex children preserved via SSR
COMP-024	Components	<Card><p/>{show() && <X/>}</Card>	No children prop (SSR DOM preserved)	preserve	✅ Implemented	Mixed JSX children preserved
COMP-025	Components	<Label>{count()}</Label>	children: () => count()	clientJs	✅ Implemented	Pure text reactive children
COMP-026	Components	<Card>{text()}{show() ? <A/> : <B/>}</Card>	No children prop (text not reactive)	preserve	⚠️ Limitation	Mixed text+JSX children - text part not reactive
COMP-030	Components	Component with signals/events	clientJs: function initComponentName(i, scope) {...}	clientJs	✅ Implemented	Init fn generated
COMP-031	Components	Static component (no signals/events)	No clientJs generated	preserve	✅ Implemented	No init wrapper
COMP-032	Components	<Parent><Child with signals/></Parent>	Parent clientJs: initChild(i, scope)	clientJs	✅ Implemented	Parent calls child init
COMP-033	Components	Auto-hydration	document.querySelectorAll('[data-bf-scope]')	clientJs	✅ Implemented	Auto-hydration
COMP-034	Components	Component compilation	{ hash: 'abc123', filename: 'Component.bf.js' }	clientJs	✅ Implemented	Hash generated
COMP-035	Components	fn({ variant, size }) with prop getters	{ variant: variant(), size: size() }	clientJs	✅ Implemented	Shorthand property expansion
COMP-040	Components	<ul>{items().map(i => <Item i={i}/>)}</ul>	Item JSX inlined in template	both	✅ Implemented	Inlined component
COMP-041	Components	Inlined component with onClick	data-event-id added	both	✅ Implemented	Inlined events
COMP-042	Components	Inlined component with conditional	Conditional in template	both	✅ Implemented	Inlined conditional
EVT-001	Events	<button onClick={() => setCount(n => n+1)}>	clientJs: _0.onclick = () => setCount(n => n+1)	both	✅ Implemented	Click handler
EVT-002	Events	<button onClick={fn1}/><button onClick={fn2}/>	clientJs: _0.onclick = fn1; _1.onclick = fn2	both	✅ Implemented	Multiple handlers
EVT-003	Events	<input onChange={(e) => setText(e.target.value)}/>	clientJs: _0.onchange = (e) => ...	both	✅ Implemented	Change handler
EVT-004	Events	<input onInput={(e) => setText(e.target.value)}/>	clientJs: _0.oninput = (e) => ...	both	✅ Implemented	Input handler
EVT-005	Events	<form onSubmit={(e) => { e.preventDefault() }}>	clientJs: _0.onsubmit = (e) => ...	both	✅ Implemented	Submit handler
EVT-006	Events	<input onKeyDown={(e) => e.key === 'Enter' && fn()}>	clientJs: _0.onkeydown = (e) => ...	both	✅ Implemented	KeyDown handler
EVT-007	Events	<input onBlur={() => validate()}/>	clientJs: addEventListener('blur', fn, { capture: true })	both	✅ Implemented	onBlur E2E test
EVT-008	Events	<input onFocus={() => highlight()}/>	clientJs: addEventListener('focus', fn, { capture: true })	both	✅ Implemented	onFocus E2E test
EVT-010	Events	<ul>{items().map(i => <li onClick={...}>)}</ul>	markedJsx: data-event-id='0' data-index={__index}	both	✅ Implemented	List delegation
EVT-011	Events	<li onClick={...} onDoubleClick={...}>	Multiple data-event-id attrs	both	✅ Implemented	Multiple list events
EVT-012	Events	<li onFocus={...}> in list	addEventListener with capture	both	✅ Implemented	onFocus in list E2E test
EVT-020	Events	onKeyDown={(e) => e.key === 'Enter' && submit()}	clientJs: if (e.key === 'Enter') { submit() }	clientJs	✅ Implemented	Conditional handler
EVT-021	Events	Complex conditional in handler	Multiple if checks in clientJs	clientJs	✅ Implemented	Complex conditional
REF-001	Refs	<input ref={(el) => inputRef = el}/>	clientJs: (el) => inputRef = el	both	✅ Implemented	Ref callback
REF-002	Refs	<input ref={...}/>	ref not in markedJsx	both	✅ Implemented	Ref excluded from server
REF-003	Refs	<input ref={...} onClick={...}/>	Both work independently	both	✅ Implemented	Ref + event
REF-004	Refs	<input ref={...} value={sig()}/>	Effect + ref both work	both	✅ Implemented	Ref + dynamic
REF-005	Refs	<input ref={ref1}/><input ref={ref2}/>	All refs executed	both	✅ Implemented	Multiple refs
EDGE-001	Edge Cases	<div> <span>X</span></div>	Space before span preserved	preserve	✅ Implemented	Trailing whitespace
EDGE-002	Edge Cases	<div></div>X	X preserved after closing	preserve	✅ Implemented	Leading text
EDGE-003	Edge Cases	<div>\n  <span>X</span>\n</div>	Indentation removed	markedJsx	✅ Implemented	Block indentation
EDGE-004	Edge Cases	<span>{' '}</span>	Space preserved	markedJsx	✅ Implemented	Explicit space
EDGE-005	Edge Cases	items().map(i => <li> {i} </li>)	Spaces in template preserved	clientJs	✅ Implemented	List whitespace
EDGE-010	Edge Cases	<a><b><c><d><e>X</e></d></c></b></a>	5 levels processed correctly	preserve	✅ Implemented	Deep nesting
EDGE-011	Edge Cases	<div><p>{a()}</p><span>{b()}</span></div>	All dynamics tracked	both	✅ Implemented	Multiple dynamics
EDGE-012	Edge Cases	<div onClick={f1}><span onClick={f2}>X</span></div>	All events attached	both	✅ Implemented	Nested events
EDGE-013	Edge Cases	items().map(i => i.x ? <A/> : <B/>)	Ternary in template	clientJs	✅ Implemented	Ternary in map
EDGE-020	Edge Cases	({a, b}) => <p>{a}</p>	Destructured params parsed	clientJs	✅ Implemented	Object destructuring
EDGE-021	Edge Cases	{x && y > 0 && <A/>}	Operators escaped correctly	both	✅ Implemented	Special chars
EDGE-022	Edge Cases	<p>{a() + b() + c()}</p>	All 3 signals tracked	both	✅ Implemented	Multiple deps
EDGE-023	Edge Cases	<style>{'.foo:hover { }'}</style>	:hover not replaced	preserve	✅ Implemented	CSS pseudo-class
EDGE-024	Edge Cases	<input type='checkbox'/>	type not replaced	preserve	✅ Implemented	HTML attr name
EDGE-030	Edge Cases	<svg><path/></svg>	<svg xmlns='http://www.w3.org/2000/svg'>	markedJsx	✅ Implemented	SVG xmlns
EDGE-031	Edge Cases	<svg viewBox='0 0 24 24'>	viewBox preserved (camelCase)	preserve	✅ Implemented	SVG viewBox
EDGE-032	Edge Cases	<path stroke-width='2'/>	stroke-width preserved	preserve	✅ Implemented	SVG stroke
EDGE-033	Edge Cases	<path fill={color()}/>	clientJs: _0.setAttribute('fill', color())	both	✅ Implemented	Dynamic SVG attr
EDGE-034	Edge Cases	<svg onClick={fn}>	clientJs: _0.onclick = fn	both	✅ Implemented	SVG event
EDGE-035	Edge Cases	<svg><g><g><path/></g></g></svg>	Nested groups rendered	preserve	✅ Implemented	Nested SVG
EDGE-040	Edge Cases	<input value={text()} onChange={...}/>	Dynamic value binding	both	✅ Implemented	Input value
EDGE-041	Edge Cases	<input type='number' value={num()}/>	type='number' preserved	both	✅ Implemented	Number input
EDGE-042	Edge Cases	<textarea value={text()}/>	Textarea value binding	both	✅ Implemented	Textarea
EDGE-043	Edge Cases	<select value={selected()}><option>...</option></select>	Select value binding	both	✅ Implemented	Select
EDGE-044	Edge Cases	<input type='checkbox' checked={isOn()}/>	checked property	both	✅ Implemented	Checkbox
EDGE-045	Edge Cases	<input type='radio' checked={isA()}/>	checked property	both	✅ Implemented	Radio
EDGE-046	Edge Cases	<input value={a()}/><input value={b()}/>	Both tracked	both	✅ Implemented	Multiple inputs
EDGE-047	Edge Cases	<input placeholder={hint()}/>	setAttribute('placeholder', ...)	both	✅ Implemented	Dynamic placeholder
EDGE-048	Edge Cases	<input disabled={isDisabled()}/>	_0.disabled = isDisabled()	both	✅ Implemented	Dynamic disabled
DIR-001	Directives	import { createSignal } from '@barefootjs/dom' (no directive)	Error: 'use client' required	error	✅ Implemented	Directive required
DIR-002	Directives	<button onClick={...}> (no directive)	Error: 'use client' required	error	✅ Implemented	Events need directive
DIR-003	Directives	const x = 1; 'use client'	Error: directive must be first	error	✅ Implemented	Directive position
DIR-004	Directives	'use client' or 'use client'	Both accepted	preserve	✅ Implemented	Quote style
DIR-005	Directives	// comment\n'use client'	Comments before allowed	preserve	✅ Implemented	Comments ok
DIR-006	Directives	Client Component imports Server Component	Error: Cannot import Server Component from Client Component	error	✅ Implemented	Client/Server boundary enforcement
PATH-001	Element Paths	<div data-bf='0'>	scope.firstChild	clientJs	✅ Implemented	Direct path
PATH-002	Element Paths	<div><p><span data-bf='0'>	scope.firstChild.firstChild.firstChild	clientJs	✅ Implemented	Chained path
PATH-003	Element Paths	<div>text<span data-bf='0'>	Text nodes skipped in path	clientJs	✅ Implemented	Text node skip
PATH-004	Element Paths	<><p data-bf='0'/><span data-bf='1'/></>	Path per fragment child	clientJs	✅ Implemented	Fragment paths
PATH-005	Element Paths	<div><Child/><span data-bf='0'/>	null (uses querySelector)	clientJs	✅ Implemented	After component
PATH-006	Element Paths	<div>{show() && <X/>}<span data-bf='0'>	Conditional skipped	clientJs	✅ Implemented	Conditional in path
PATH-007	Element Paths	{cond ? <X/> : null}<span data-bf='0'>{text()}</span>	path: null (querySelector fallback)	clientJs	✅ Implemented	Elements after conditionals use querySelector
PATH-008	Element Paths	{c1 && <X/>}{c2 && <Y/>}<span data-bf='0'>	path: null (querySelector fallback)	clientJs	✅ Implemented	Multiple conditionals before element
TYPE-001	Type Preservation	interface Props { x: string }	interface Props { x: string } in output	markedJsx	✅ Implemented	Interface definition preserved
TYPE-002	Type Preservation	interface ChildProps extends ParentProps { x: number }	Both interfaces extracted	markedJsx	✅ Implemented	Interface inheritance (local)
TYPE-003	Type Preservation	type Props = { x: string }	type Props = { x: string } in output	markedJsx	✅ Implemented	Type alias preserved
TYPE-004	Type Preservation	type Props = BaseProps & { x: string }	Intersection type preserved	markedJsx	✅ Implemented	Intersection type resolved
TYPE-005	Type Preservation	function C({ x }: Props)	C({ x }: Props & { "data-key"?: ... })	markedJsx	✅ Implemented	Uses intersection for hydration props
TYPE-006	Type Preservation	interface Props extends HTMLAttributes<...>	Interface preserved, external type referenced	markedJsx	✅ Implemented	External types not extracted
TYPE-010	Type Preservation	interface Props<T> { items: T[] }	Not resolved (falls back to unknown)	n/a	❌ Not Supported	Generic interfaces
TYPE-011	Type Preservation	type Props = Pick<T, K>	Not resolved (falls back to unknown)	n/a	❌ Not Supported	Utility types (Pick, Omit, etc.)
TYPE-012	Type Preservation	type Props = T extends U ? X : Y	Not resolved (falls back to unknown)	n/a	❌ Not Supported	Conditional types
TYPE-013	Type Preservation	type Props = { [K in Keys]: V }	Not resolved (falls back to unknown)	n/a	❌ Not Supported	Mapped types
TYPE-014	Type Preservation	function C({ x }: Props & { extra: string })	Inline intersection not preserved	markedJsx	❌ Not Supported	Inline intersection type annotation
OOS-001	Out of Scope	useEffect(() => {...})	Not supported	n/a	❌ OOS	Use createEffect
OOS-002	Out of Scope	useState(0)	Not supported	n/a	❌ OOS	Use createSignal
OOS-003	Out of Scope	<Context.Provider value={...}>	Not supported	n/a	❌ OOS	Pass props
OOS-004	Out of Scope	dangerouslySetInnerHTML={{__html: x}}	Not supported	n/a	❌ OOS	Security
OOS-005	Out of Scope	class C extends Component {...}	Not supported	n/a	❌ OOS	Function only
OOS-006	Out of Scope	forwardRef((props, ref) => ...)	Not supported	n/a	❌ OOS	Use ref callbacks
OOS-007	Out of Scope	<ErrorBoundary>...</ErrorBoundary>	Not supported	n/a	❌ OOS	Handle in code
OOS-008	Out of Scope	<Suspense><lazy(...)></Suspense>	Not supported	n/a	❌ OOS	Manual splitting
OOS-009	Out of Scope	createPortal(<Modal/>, document.body)	Not supported	n/a	❌ OOS	Manual DOM
OOS-010	Out of Scope	var x = 1 (in component)	var not extracted	n/a	❌ OOS	Use const/let
OOS-011	Out of Scope	async function Component() {...}	Not supported	n/a	❌ OOS	Use signals
OOS-012	Out of Scope	const Comp = cond ? A : 'button'; <Comp>	Not supported	n/a	❌ OOS	Polymorphic rendering - use conditional JSX
