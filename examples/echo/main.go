package main

import (
	"encoding/json"
	"html/template"
	"io"
	"net/http"
	"reflect"
	"strconv"
	"strings"
	"sync"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

// bfFuncMap contains BarefootJS template functions
var bfFuncMap = template.FuncMap{
	// bfComment outputs an HTML comment with "bf-" prefix.
	// Example: {{bfComment "cond-start:slot_2"}} outputs <!--bf-cond-start:slot_2-->
	"bfComment": func(key string) template.HTML {
		return template.HTML("<!--bf-" + key + "-->")
	},
}

// loadTemplates loads all templates with BarefootJS functions registered
func loadTemplates() *template.Template {
	return template.Must(
		template.New("").Funcs(bfFuncMap).ParseGlob("dist/templates/*.tmpl"),
	)
}

// CounterProps represents the props for the Counter component.
// Generated by @barefootjs/go-template adapter.
type CounterProps struct {
	ScopeID string `json:"scopeID"`
	Initial int    `json:"initial"`
	Count   int    `json:"count"`
	Doubled int    `json:"doubled"`
}

// ToggleItemProps represents props for individual toggle items.
type ToggleItemProps struct {
	ScopeID   string `json:"scopeID"`
	Label     string `json:"label"`
	DefaultOn bool   `json:"defaultOn"`
	On        bool   `json:"on"`
}

// ToggleProps represents the props for the Toggle component.
type ToggleProps struct {
	ScopeID     string            `json:"scopeID"`
	ToggleItems []ToggleItemProps `json:"toggleItems"`
}

// FizzBuzzCounterProps represents the props for the FizzBuzzCounter component.
type FizzBuzzCounterProps struct {
	ScopeID     string `json:"scopeID"`
	Count       int    `json:"count"`
	ShowDetails bool   `json:"showDetails"`
	Doubled     int    `json:"doubled"`
}

// DashboardProps represents the props for the Dashboard component.
type DashboardProps struct {
	ScopeID      string `json:"scopeID"`
	ShowCounter  bool   `json:"showCounter"`
	ShowMessage  bool   `json:"showMessage"`
	InitialCount int    `json:"initialCount"`
	Message      string `json:"message"`
	Count        int    `json:"count"`
	Text         string `json:"text"`
}

// Todo represents a single todo item.
type Todo struct {
	ID   int    `json:"id"`
	Text string `json:"text"`
	Done bool   `json:"done"`
}

// TodoAppProps represents the props for the TodoApp component.
type TodoAppProps struct {
	ScopeID      string `json:"scopeID"`
	InitialTodos []Todo `json:"initialTodos"`
	Todos        []Todo `json:"todos"`
	DoneCount    int    `json:"doneCount"`
}

// In-memory todo storage
var (
	todoMutex  sync.RWMutex
	todoNextID = 4
	todos      = []Todo{
		{ID: 1, Text: "Setup project", Done: false},
		{ID: 2, Text: "Create components", Done: false},
		{ID: 3, Text: "Write tests", Done: true},
	}
)

// Reset todos to initial state (for testing)
func resetTodos() {
	todoMutex.Lock()
	defer todoMutex.Unlock()
	todoNextID = 4
	todos = []Todo{
		{ID: 1, Text: "Setup project", Done: false},
		{ID: 2, Text: "Create components", Done: false},
		{ID: 3, Text: "Write tests", Done: true},
	}
}

// Template renderer for Echo
type TemplateRenderer struct {
	templates *template.Template
}

func (t *TemplateRenderer) Render(w io.Writer, name string, data interface{}, c echo.Context) error {
	return t.templates.ExecuteTemplate(w, name, data)
}

func main() {
	e := echo.New()

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Load templates with BarefootJS functions
	t := &TemplateRenderer{
		templates: loadTemplates(),
	}
	e.Renderer = t

	// Routes
	e.GET("/", indexHandler)
	e.GET("/counter", counterHandler)
	e.GET("/toggle", toggleHandler)
	e.GET("/fizzbuzz", fizzbuzzHandler)
	e.GET("/dashboard", dashboardHandler)
	e.GET("/dashboard/counter-only", dashboardCounterOnlyHandler)
	e.GET("/dashboard/message-only", dashboardMessageOnlyHandler)
	e.GET("/todos", todosHandler)

	// Todo API endpoints
	e.GET("/api/todos", getTodosAPI)
	e.POST("/api/todos", createTodoAPI)
	e.PUT("/api/todos/:id", updateTodoAPI)
	e.DELETE("/api/todos/:id", deleteTodoAPI)
	e.POST("/api/todos/reset", resetTodosAPI)

	// Static files (for client JS)
	e.Static("/static", "dist")

	// Shared styles
	e.Static("/shared", "../shared")

	e.Logger.Fatal(e.Start(":8080"))
}

func indexHandler(c echo.Context) error {
	return c.HTML(http.StatusOK, `
<!DOCTYPE html>
<html>
<head>
    <title>BarefootJS + Echo Example</title>
    <style>
        body { font-family: system-ui, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        h1 { color: #333; }
        a { color: #0066cc; }
    </style>
</head>
<body>
    <h1>BarefootJS + Echo Example</h1>
    <p>This example demonstrates server-side rendering with Go Echo and BarefootJS.</p>
    <ul>
        <li><a href="/counter">Counter Component</a></li>
        <li><a href="/toggle">Toggle Component</a></li>
        <li><a href="/fizzbuzz">FizzBuzzCounter Component</a></li>
        <li><a href="/dashboard">Dashboard Component</a></li>
        <li><a href="/todos">TodoApp Component</a></li>
    </ul>
</body>
</html>
`)
}

func counterHandler(c echo.Context) error {
	// Initial count value (could come from query param, database, etc.)
	initial := 0

	props := CounterProps{
		ScopeID: "Counter_1", // Must match pattern: ComponentName_instanceId
		Initial: initial,
		Count:   initial,
		Doubled: initial * 2,
	}

	// Wrap the component in a full HTML page
	return c.HTML(http.StatusOK, renderPage("Counter", props))
}

func renderPage(componentName string, props interface{}) string {
	t := loadTemplates()

	// Get ScopeID from props using reflection
	scopeID := ""
	propsJSON := "{}"
	if propsVal := getField(props, "ScopeID"); propsVal != "" {
		scopeID = propsVal
	}

	// Serialize props to JSON for client hydration
	if jsonBytes, err := json.Marshal(props); err == nil {
		propsJSON = string(jsonBytes)
	}

	// Create a page template that includes the component
	pageHTML := `
<!DOCTYPE html>
<html>
<head>
    <title>` + componentName + ` - BarefootJS + Echo</title>
    <link rel="stylesheet" href="/shared/styles/components.css">
    <style>
        body { font-family: system-ui, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
    </style>
</head>
<body>
    <h1>` + componentName + ` Component</h1>
    <div id="app">`

	// Render the component
	var buf strings.Builder
	buf.WriteString(pageHTML)

	t.ExecuteTemplate(&buf, componentName, props)

	// Add props JSON for client hydration
	if scopeID != "" {
		buf.WriteString(`<script type="application/json" data-bf-props="` + scopeID + `">` + propsJSON + `</script>`)
	}

	buf.WriteString(`</div>
    <p><a href="/">‚Üê Back to index</a></p>

    <script type="module" src="/static/client/` + componentName + `.client.js"></script>
</body>
</html>`)

	return buf.String()
}

// getField extracts a string field from a struct using reflection
func getField(v interface{}, field string) string {
	val := reflect.ValueOf(v)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	if val.Kind() != reflect.Struct {
		return ""
	}
	f := val.FieldByName(field)
	if !f.IsValid() {
		return ""
	}
	if f.Kind() == reflect.String {
		return f.String()
	}
	return ""
}

func toggleHandler(c echo.Context) error {
	props := ToggleProps{
		ScopeID: "Toggle_1",
		ToggleItems: []ToggleItemProps{
			{ScopeID: "ToggleItem_1", Label: "Setting 1", DefaultOn: true, On: true},
			{ScopeID: "ToggleItem_2", Label: "Setting 2", DefaultOn: false, On: false},
			{ScopeID: "ToggleItem_3", Label: "Setting 3", DefaultOn: false, On: false},
		},
	}

	return c.HTML(http.StatusOK, renderPage("Toggle", props))
}

func fizzbuzzHandler(c echo.Context) error {
	props := FizzBuzzCounterProps{
		ScopeID:     "FizzBuzzCounter_1",
		Count:       0,
		ShowDetails: false,
		Doubled:     0,
	}

	return c.HTML(http.StatusOK, renderPage("FizzBuzzCounter", props))
}

func dashboardHandler(c echo.Context) error {
	props := DashboardProps{
		ScopeID:      "Dashboard_1",
		ShowCounter:  true,
		ShowMessage:  true,
		InitialCount: 10,
		Message:      "Hello from server!",
		Count:        10,
		Text:         "Hello from server!",
	}

	return c.HTML(http.StatusOK, renderPage("Dashboard", props))
}

func dashboardCounterOnlyHandler(c echo.Context) error {
	props := DashboardProps{
		ScopeID:      "Dashboard_1",
		ShowCounter:  true,
		ShowMessage:  false,
		InitialCount: 5,
		Message:      "",
		Count:        5,
		Text:         "",
	}

	return c.HTML(http.StatusOK, renderPage("Dashboard", props))
}

func dashboardMessageOnlyHandler(c echo.Context) error {
	props := DashboardProps{
		ScopeID:      "Dashboard_1",
		ShowCounter:  false,
		ShowMessage:  true,
		InitialCount: 0,
		Message:      "Custom message!",
		Count:        0,
		Text:         "Custom message!",
	}

	return c.HTML(http.StatusOK, renderPage("Dashboard", props))
}

func todosHandler(c echo.Context) error {
	todoMutex.RLock()
	currentTodos := make([]Todo, len(todos))
	copy(currentTodos, todos)
	todoMutex.RUnlock()

	// Count done todos
	doneCount := 0
	for _, t := range currentTodos {
		if t.Done {
			doneCount++
		}
	}

	props := TodoAppProps{
		ScopeID:      "TodoApp_1",
		InitialTodos: currentTodos,
		Todos:        currentTodos,
		DoneCount:    doneCount,
	}

	return c.HTML(http.StatusOK, renderPage("TodoApp", props))
}

// Todo API handlers
func getTodosAPI(c echo.Context) error {
	todoMutex.RLock()
	defer todoMutex.RUnlock()
	return c.JSON(http.StatusOK, todos)
}

func createTodoAPI(c echo.Context) error {
	var input struct {
		Text string `json:"text"`
	}
	if err := json.NewDecoder(c.Request().Body).Decode(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid input"})
	}

	todoMutex.Lock()
	newTodo := Todo{
		ID:   todoNextID,
		Text: input.Text,
		Done: false,
	}
	todoNextID++
	todos = append(todos, newTodo)
	todoMutex.Unlock()

	return c.JSON(http.StatusCreated, newTodo)
}

func updateTodoAPI(c echo.Context) error {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid id"})
	}

	var input struct {
		Text *string `json:"text"`
		Done *bool   `json:"done"`
	}
	if err := json.NewDecoder(c.Request().Body).Decode(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid input"})
	}

	todoMutex.Lock()
	defer todoMutex.Unlock()

	for i, todo := range todos {
		if todo.ID == id {
			if input.Text != nil {
				todos[i].Text = *input.Text
			}
			if input.Done != nil {
				todos[i].Done = *input.Done
			}
			return c.JSON(http.StatusOK, todos[i])
		}
	}

	return c.JSON(http.StatusNotFound, map[string]string{"error": "not found"})
}

func deleteTodoAPI(c echo.Context) error {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid id"})
	}

	todoMutex.Lock()
	defer todoMutex.Unlock()

	for i, todo := range todos {
		if todo.ID == id {
			todos = append(todos[:i], todos[i+1:]...)
			return c.NoContent(http.StatusNoContent)
		}
	}

	return c.JSON(http.StatusNotFound, map[string]string{"error": "not found"})
}

func resetTodosAPI(c echo.Context) error {
	resetTodos()
	return c.NoContent(http.StatusOK)
}
